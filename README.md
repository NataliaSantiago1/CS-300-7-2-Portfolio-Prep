# CS-300-7-2-Portfolio-Prep

The course presented a variety of applications for the problem we had to address, but the fundamental idea was always the same: we had to organize lists of data, usually CSV files, and make it possible for users to retrieve the data in a clean, repeatable manner. To achieve these objectives, we employed a variety of data structures and algorithms.

I've learned to schedule my code's execution before I write a single line of code. This gave me a better understanding of the application I was building and helped me visualize it more clearly before I even started writing the code. It also helped me understand the technical aspects of the code, such as which structures and meta-heuristics to use. I also had to think about what data structure would help me achieve my objective most effectively. Data structures come in a wide variety of forms, and we value them all because they are useful in different contexts and have varied applications. We also value these data structures greatly since they enable outside observers of our code to predict behavior of the code and troubleshoot issues that may arise.

The main difficulty I encountered with this project was properly comprehending the intended appearance and behavior of the data structures themselves. Nevertheless, after watching a few videos on them, everything began to make sense to me. I watched a lot of videos on YouTube and perused a lot of "stackoverflow.com" questions and answers. I was able to grasp the principles being employed in my application on a much deeper level because these questions and answers were typically significantly more in-depth than what was required for my study.

I discovered that even though I still have a tendency to solve problems more quickly—by resolving bugs and making modifications to the code or program as I go—I still tended to rely on my pseudocode, program drawings, and the different data structures and code structures that I intended to utilize. In the future, I envision myself devoting more effort to planning than to coding as I go. I also learned why effective coding and program building require compiling and executing as you go.

Once more, I will undoubtedly dedicate more time to program planning in the future. My program could definitely be made a little more understandable by changing the names of variables and functions, increasing the amount of whitespace used, and adding a few block comments to clarify some of the logic. It's also likely that I could have included fewer libraries.
